"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  languages: () => languages,
  options: () => options,
  parsers: () => parsers,
  printers: () => printers
});
module.exports = __toCommonJS(src_exports);
var import_path = require("path");
var import_module = require("module");
var import_prettier5 = require("prettier");
var defaultCompiler = __toESM(require("@marko/compiler"));
var import_config = __toESM(require("@marko/compiler/config"));
var defaultTranslator = __toESM(require("@marko/translator-default"));

// src/constants.ts
var enclosedNodeTypeReg = /^(?:Identifier|.*Literal|(?:Object|Array|Parenthesized|Record|Tuple)Expression)$/;
var styleReg = /^style((?:\.[^\s\\/:*?"<>|({]+)+)?\s*\{?/;
var voidHTMLReg = /^(?:area|b(?:ase|r)|col|embed|hr|i(?:mg|nput)|keygen|link|meta|param|source|track|wbr)$/;
var shorthandIdOrClassReg = /^[a-zA-Z0-9_$][a-zA-Z0-9_$-]*(?:\s+[a-zA-Z0-9_$][a-zA-Z0-9_$-]*)*$/;
var preserveSpaceTagsReg = /^(?:textarea|pre)$/;

// src/utils/loc-to-pos.ts
function locToPos(loc, opts) {
  const { markoLinePositions } = opts;
  return markoLinePositions[loc.line - 1] + loc.column + (loc.line === 1 ? 0 : 1);
}

// src/utils/call-embed.ts
function callEmbed(print, path, mode, code) {
  const node = path.getValue();
  if (!code.trim()) {
    return "";
  }
  node._embed = {
    type: "_MarkoEmbed",
    mode,
    code,
    loc: void 0
  };
  try {
    return path.call(print, "_embed");
  } finally {
    node._embed = void 0;
  }
}

// src/utils/is-text-like.ts
function isTextLike(node, parent) {
  if (isText(node)) {
    return true;
  } else if (node.type === "MarkoComment") {
    const body = parent.type === "Program" ? parent.body : parent.body.body;
    const i = body.indexOf(node);
    let j = i;
    while (j > 0) {
      const check = body[--j];
      if (isText(check))
        return true;
      else if (check.type !== "MarkoComment")
        break;
    }
    j = i;
    while (j < body.length - 1) {
      const check = body[++j];
      if (isText(check))
        return true;
      else if (check.type !== "MarkoComment")
        break;
    }
  }
  return false;
}
function isText(node) {
  return node.type === "MarkoText" || node.type === "MarkoPlaceholder";
}

// src/utils/with-line-if-needed.ts
var import_prettier = require("prettier");
var { builders: b } = import_prettier.doc;
function withLineIfNeeded(node, opts, doc6) {
  const { originalText } = opts;
  let pos = locToPos(node.loc.start, opts);
  let count = 0;
  while (--pos >= 0) {
    let char = originalText[pos];
    if (char === "\n") {
      if (++count === 2) {
        while (--pos >= 0) {
          char = originalText[pos];
          if (char !== "\n" && char !== "	" && char !== "\r" && char !== " ") {
            return [b.hardline, doc6];
          }
        }
        return doc6;
      }
    } else if (char !== "	" && char !== "\r" && char !== " ") {
      break;
    }
  }
  return doc6;
}

// src/utils/with-block-if-needed.ts
var import_prettier2 = require("prettier");

// src/utils/outer-code-matches.ts
var enclosedPatterns = [];
enclosedPatterns.push(
  {
    // Ignored
    match: /[a-z0-9_$#@.]+/iy
  },
  {
    // Line comments
    match: /\/\/.*$/y
  },
  {
    // Multi line comments
    match: /\/\*.*?\*\//y
  },
  {
    // Parens
    match: /\(/y,
    patterns: enclosedPatterns,
    until: /\)/y
  },
  {
    // Braces
    match: /{/y,
    patterns: enclosedPatterns,
    until: /}/y
  },
  {
    // Brackets
    match: /\[/y,
    patterns: enclosedPatterns,
    until: /]/y
  },
  {
    // Single quote string
    match: /'(?:\\.|[^'\\]+)*'/y
  },
  {
    // Double quote string
    match: /"(?:\\.|[^"\\]+)*"/y
  },
  {
    // Template literal
    match: /`/y,
    patterns: [
      {
        // Content
        match: /\\.|\$(?!{)|[^`\\$]+/y
      },
      {
        // Expressions
        match: /\${/y,
        patterns: enclosedPatterns,
        until: /}/y
      }
    ],
    until: /`/y
  },
  {
    // RegExp
    match: /\/(?:\\.|\[(?:\\.|[^\]\\]+)\]|[^[/\\])+\/[a-z]*/iy
  }
);
var unenclosedPatterns = [
  {
    // Word operators
    match: /(?<=\b)\s*(?:as|in(?:stanceof)?|new|void|delete|keyof|typeof)\s+/y
  },
  {
    // Symbol operators
    match: /\s*(?:[\^~%!]|\+{1,2}|\*{1,2}|-(?:-(?!\s))?|&{1,2}|\|{1,2}|!={0,2}|===?|<{2,3}|>{2,3}|<=?|>=)\s*/y
  }
].concat(enclosedPatterns);
function outerCodeMatches(str, test, enclosed) {
  const stack = [
    {
      until: test,
      patterns: enclosed ? enclosedPatterns : unenclosedPatterns
    }
  ];
  let pos = 0;
  do {
    const { until, patterns } = stack[stack.length - 1];
    outer:
      while (pos < str.length) {
        for (const pattern of patterns) {
          pattern.match.lastIndex = pos;
          if (pattern.match.test(str)) {
            pos = pattern.match.lastIndex;
            if (pattern.until) {
              stack.push(pattern);
              break outer;
            } else {
              continue outer;
            }
          }
        }
        until.lastIndex = pos;
        if (until.test(str)) {
          pos = until.lastIndex;
          if (stack.length === 1)
            return true;
          stack.pop();
          break;
        }
        pos++;
      }
  } while (pos < str.length && stack.length);
  return false;
}

// src/utils/get-original-code.ts
var import_generator = __toESM(require("@babel/generator"));
var generate = import_generator.default.default || import_generator.default;
function getOriginalCodeForNode(opts, node) {
  var _a, _b;
  const loc = node.loc;
  if (!loc) {
    return generate(node, {
      filename: opts.filepath,
      compact: false,
      comments: true,
      sourceMaps: false
    }).code;
  }
  let start = loc.start;
  if ((_a = node.leadingComments) == null ? void 0 : _a.length) {
    const commentStart = node.leadingComments[0].loc.start;
    if (commentStart.line < start.line || commentStart.line === start.line && commentStart.column < start.column) {
      start = commentStart;
    }
  }
  let end = loc.end;
  if ((_b = node.trailingComments) == null ? void 0 : _b.length) {
    const commentEnd = node.trailingComments[node.trailingComments.length - 1].loc.end;
    if (commentEnd.line > end.line || commentEnd.line === end.line && commentEnd.column > end.column) {
      end = commentEnd;
    }
  }
  return opts.originalText.slice(locToPos(start, opts), locToPos(end, opts));
}
function getOriginalCodeForList(opts, sep, list) {
  return list.map((node) => getOriginalCodeForNode(opts, node)).join(sep);
}

// src/utils/with-block-if-needed.ts
var { builders: b2 } = import_prettier2.doc;
function withBlockIfNeeded(node, opts, docs) {
  if (!enclosedNodeTypeReg.test(node.type) && outerCodeMatches(
    (0, import_prettier2.format)(getOriginalCodeForNode(opts, node), {
      ...opts,
      printWidth: 0,
      parser: opts.markoScriptParser
    }).trim(),
    /[\n\r]/y
  )) {
    return b2.group([
      b2.indent([b2.ifBreak(["{", b2.line]), docs]),
      b2.ifBreak([b2.line, "}"])
    ]);
  }
  return docs;
}

// src/utils/with-parens-if-needed.ts
var import_prettier3 = require("prettier");
var { builders: b3 } = import_prettier3.doc;
function withParensIfNeeded(node, opts, doc6) {
  var _a, _b;
  if (((_a = node.leadingComments) == null ? void 0 : _a.length) || ((_b = node.trailingComments) == null ? void 0 : _b.length) || !enclosedNodeTypeReg.test(node.type) && outerCodeMatches(
    (0, import_prettier3.format)(`_(${getOriginalCodeForNode(opts, node)})`, {
      ...opts,
      printWidth: 0,
      parser: opts.markoScriptParser
    }).replace(/^_\(([\s\S]*)\);?$/m, "$1").trim(),
    /\s|>/y,
    opts.markoAttrParen
  )) {
    return b3.group(["(", b3.indent([b3.softline, doc6]), b3.softline, ")"]);
  }
  return doc6;
}
function withParensIfBreak(node, opts, doc6) {
  var _a, _b;
  if (((_a = node.leadingComments) == null ? void 0 : _a.length) || ((_b = node.trailingComments) == null ? void 0 : _b.length) || !enclosedNodeTypeReg.test(node.type) && outerCodeMatches(
    (0, import_prettier3.format)(`_(${getOriginalCodeForNode(opts, node)})`, {
      ...opts,
      printWidth: 0,
      parser: opts.markoScriptParser
    }).replace(/^_\(([\s\S]*)\);?$/m, "$1").trim(),
    /\n/y,
    true
  )) {
    return b3.group([
      b3.ifBreak("(", ""),
      b3.indent([b3.softline, doc6]),
      b3.softline,
      b3.ifBreak(")", "")
    ]);
  }
  return doc6;
}

// src/utils/as-literal-text-content.ts
var import_prettier4 = require("prettier");
var { builders: b4 } = import_prettier4.doc;
var temp = [""];
function asLiteralTextContent(val) {
  let charPos = 0;
  let slotPos = 0;
  for (let i = 0, len = val.length; i < len; i++) {
    switch (val.charAt(i)) {
      case "\\":
        temp.push("\\\\");
        break;
      case "\n":
        temp.push(b4.literalline);
        break;
      default:
        continue;
    }
    temp[slotPos] = val.slice(charPos, i);
    slotPos = temp.push("") - 1;
    charPos = i + 1;
  }
  if (charPos) {
    const result = temp;
    result[slotPos] = val.slice(charPos);
    temp = [""];
    return result;
  } else {
    return val;
  }
}

// src/index.ts
var defaultFilePath = (0, import_path.resolve)("index.marko");
var rootRequire = (0, import_module.createRequire)(defaultFilePath);
var { builders: b5, utils } = import_prettier5.doc;
var identity = (val) => val;
var embeddedPlaceholderReg = /__EMBEDDED_PLACEHOLDER_(\d+)__/g;
var expressionParser = (code, parsers2, options2) => {
  const ast = parsers2["babel-ts"](code, options2);
  const { tokens, comments, range } = ast;
  const node = ast.program.body[0].expression;
  return {
    type: "JsExpressionRoot",
    tokens,
    comments,
    node,
    range
  };
};
var [{ compileSync, types: t }, config] = (() => {
  try {
    return [
      rootRequire("@marko/compiler"),
      rootRequire("@marko/compiler/config")
    ];
  } catch {
    return [defaultCompiler, import_config.default];
  }
})();
var translator = (() => {
  try {
    return rootRequire(config.translator);
  } catch {
    return defaultTranslator;
  }
})();
var languages = [
  {
    name: "marko",
    aceMode: "text",
    parsers: ["marko"],
    aliases: ["markojs"],
    tmScope: "text.marko",
    codemirrorMode: "htmlmixed",
    vscodeLanguageIds: ["marko"],
    linguistLanguageId: 932782397,
    codemirrorMimeType: "text/html",
    extensions: [".marko"]
  }
];
var options = {
  markoSyntax: {
    since: "",
    type: "choice",
    default: "auto",
    category: "Marko",
    description: "Change output syntax between HTML mode, concise mode and auto.",
    choices: [
      {
        value: "auto",
        description: "Determine output syntax by the input syntax used."
      },
      {
        value: "html",
        description: "Force the output to use the HTML syntax."
      },
      {
        value: "concise",
        description: "Force the output to use the concise syntax."
      }
    ]
  },
  markoAttrParen: {
    since: "",
    type: "boolean",
    default: (() => {
      try {
        let compilerRequire;
        try {
          compilerRequire = (0, import_module.createRequire)(
            rootRequire.resolve("@marko/compiler")
          );
        } catch {
          compilerRequire = (0, import_module.createRequire)(rootRequire.resolve("marko"));
        }
        const [major, minor] = compilerRequire("htmljs-parser/package.json").version.split(".").map((v) => parseInt(v, 10));
        return major < 2 || major === 2 && minor < 11;
      } catch {
        return false;
      }
    })(),
    category: "Marko",
    description: "If enabled all attributes with unenclosed whitespace will be wrapped in parens."
  }
};
var parsers = {
  marko: {
    astFormat: "marko-ast",
    parse(text, _parsers, opts) {
      const { filepath = defaultFilePath } = opts;
      const { ast } = compileSync(`${text}
`, filepath, {
        ast: true,
        code: false,
        optimize: false,
        output: "source",
        sourceMaps: false,
        writeVersionComment: false,
        translator,
        babelConfig: {
          caller: { name: "@marko/prettier" },
          babelrc: false,
          configFile: false,
          parserOpts: {
            allowUndeclaredExports: true,
            allowAwaitOutsideFunction: true,
            allowReturnOutsideFunction: true,
            allowImportExportEverywhere: true,
            plugins: ["exportDefaultFrom", "importAssertions"]
          }
        }
      });
      opts.originalText = text;
      opts.markoLinePositions = [0];
      opts.markoScriptParser = "babel-ts";
      opts.markoPreservingSpace = false;
      for (let i = 0; i < text.length; i++) {
        if (text[i] === "\n") {
          opts.markoLinePositions.push(i);
        }
      }
      if (opts.markoSyntax === "auto") {
        opts.markoSyntax = "html";
        for (const childNode of ast.program.body) {
          if (t.isMarkoTag(childNode)) {
            if (t.isStringLiteral(childNode.name) && childNode.name.value === "style" && styleReg.exec(childNode.rawValue || "style")[0].endsWith("{")) {
              continue;
            }
            if (opts.originalText[locToPos(childNode.loc.start, opts)] !== "<") {
              opts.markoSyntax = "concise";
            }
            break;
          }
        }
      }
      return ast;
    },
    locStart() {
      return 0;
    },
    locEnd() {
      return 0;
    }
  }
};
var printers = {
  "marko-ast": {
    print(path, opts, print) {
      var _a, _b, _c, _d;
      const node = path.getValue();
      switch (node.type) {
        case "File":
          return path.call(print, "program");
        case "Program": {
          let text = [];
          const lastIndex = node.body.length - 1;
          const bodyDocs = [];
          path.each((child, i) => {
            const childNode = child.getValue();
            const isText2 = isTextLike(childNode, node);
            if (isText2) {
              text.push(print(child));
              if (i !== lastIndex)
                return;
            }
            if (text.length) {
              const textDoc = b5.group([
                "--",
                b5.line,
                b5.fill(text),
                b5.ifBreak([b5.softline, "--"])
              ]);
              if (isText2) {
                bodyDocs.push(textDoc);
              } else {
                text = [];
                bodyDocs.push(textDoc, b5.hardline, print(child));
              }
            } else {
              bodyDocs.push(print(child));
            }
          }, "body");
          return [b5.join(b5.hardline, bodyDocs), b5.hardline];
        }
        case "MarkoDocumentType":
          return `<!${node.value.replace(/\s+/g, " ").trim()}>`;
        case "MarkoDeclaration":
          return asLiteralTextContent(`<?${node.value}?>`);
        case "MarkoComment": {
          const start = (_a = node.loc) == null ? void 0 : _a.start;
          switch (start != null && opts.originalText[locToPos(start, opts) + 1]) {
            case "/":
              return [asLiteralTextContent(`//${node.value}`), b5.hardline];
            case "*":
              return asLiteralTextContent(`/*${node.value}*/`);
            default:
              return asLiteralTextContent(`<!--${node.value}-->`);
          }
        }
        case "MarkoCDATA":
          return asLiteralTextContent(`<![CDATA[${node.value}]]>`);
        case "MarkoTag": {
          const tagPath = path;
          const groupId = Symbol();
          const doc6 = [opts.markoSyntax === "html" ? "<" : ""];
          const { markoPreservingSpace } = opts;
          const literalTagName = t.isStringLiteral(node.name) ? node.name.value : "";
          const preserveSpace = markoPreservingSpace || (opts.markoPreservingSpace = preserveSpaceTagsReg.test(literalTagName));
          let embedMode;
          if (literalTagName) {
            if (literalTagName === "script") {
              embedMode = "script";
            } else if (literalTagName === "style") {
              const [startContent, lang = ".css"] = styleReg.exec(
                node.rawValue || literalTagName
              );
              embedMode = `style.${import_prettier5.getFileInfo.sync(opts.filepath + lang).inferredParser}`;
              if (startContent.endsWith("{")) {
                const codeSartOffset = startContent.length;
                const codeEndOffset = node.rawValue.lastIndexOf("}");
                const code = node.rawValue.slice(
                  codeSartOffset,
                  codeEndOffset
                );
                return b5.group([
                  "style",
                  lang === ".css" ? "" : lang,
                  " {",
                  b5.indent([
                    b5.line,
                    callEmbed(print, tagPath, embedMode, code)
                  ]),
                  b5.line,
                  "}"
                ]);
              }
            }
            doc6.push(literalTagName);
          } else {
            doc6.push(
              b5.group([
                "${",
                b5.indent([b5.softline, tagPath.call(print, "name")]),
                b5.softline,
                "}"
              ])
            );
          }
          const shorthandIndex = doc6.push("") - 1;
          if (node.var) {
            doc6.push(
              "/",
              callEmbed(
                print,
                tagPath,
                "var",
                getOriginalCodeForNode(opts, node.var)
              )
            );
          }
          if ((_b = node.arguments) == null ? void 0 : _b.length) {
            doc6.push(
              b5.group([
                "(",
                b5.indent([
                  b5.softline,
                  b5.join(
                    [",", b5.line],
                    tagPath.map((it) => print(it), "arguments")
                  ),
                  opts.trailingComma === "all" ? b5.ifBreak(",") : ""
                ]),
                b5.softline,
                ")"
              ])
            );
          }
          if (node.body.params.length) {
            doc6.push(
              b5.group([
                "|",
                callEmbed(
                  print,
                  tagPath,
                  "params",
                  getOriginalCodeForList(opts, ",", node.body.params)
                ),
                "|"
              ])
            );
          }
          if (node.attributes.length) {
            const attrsDoc = [];
            tagPath.each((attrPath) => {
              const attrNode = attrPath.getValue();
              if (t.isMarkoAttribute(attrNode) && (attrNode.name === "class" || attrNode.name === "id")) {
                if ((literalTagName === "style" || opts.markoSyntax === "concise") && t.isStringLiteral(attrNode.value) && !attrNode.modifier && shorthandIdOrClassReg.test(attrNode.value.value)) {
                  const symbol = attrNode.name === "class" ? "." : "#";
                  doc6[shorthandIndex] += symbol + attrNode.value.value.split(/ +/).join(symbol);
                } else {
                  attrNode.value.loc = null;
                  attrsDoc.push(print(attrPath));
                }
              } else if (attrNode.default) {
                doc6.push(print(attrPath));
              } else {
                attrsDoc.push(print(attrPath));
              }
            }, "attributes");
            if (attrsDoc.length) {
              if (attrsDoc.length === 1) {
                doc6.push(" ", attrsDoc[0]);
              } else {
                doc6.push(
                  b5.group([
                    opts.markoSyntax === "concise" ? b5.ifBreak(" [") : "",
                    b5.indent([b5.line, b5.join(b5.line, attrsDoc)]),
                    opts.markoSyntax === "concise" ? b5.ifBreak([b5.line, "]"]) : b5.ifBreak(b5.line)
                  ])
                );
              }
            }
          }
          if (voidHTMLReg.test(literalTagName)) {
            if (opts.markoSyntax === "html")
              doc6.push(">");
          } else if (node.body.body.length) {
            const lastIndex = node.body.body.length - 1;
            const bodyDocs = [];
            let textOnly = true;
            if (embedMode) {
              let placeholderId = 0;
              const placeholders = [];
              let embeddedCode = "";
              tagPath.each(
                (childPath) => {
                  const childNode = childPath.getValue();
                  if (childNode.type === "MarkoText") {
                    embeddedCode += childNode.value;
                  } else {
                    embeddedCode += `__EMBEDDED_PLACEHOLDER_${placeholderId++}__`;
                    placeholders.push(print(childPath));
                  }
                },
                "body",
                "body"
              );
              const embeddedDoc = replaceEmbeddedPlaceholders(
                callEmbed(print, tagPath, embedMode, embeddedCode),
                placeholders
              );
              bodyDocs.push(
                b5.group([
                  opts.markoSyntax === "html" ? "" : b5.ifBreak("--", " --", { groupId }),
                  opts.markoSyntax === "html" ? "" : b5.line,
                  embeddedDoc,
                  opts.markoSyntax === "html" ? "" : b5.ifBreak([b5.softline, "--"])
                ])
              );
            } else {
              let textDocs = [];
              tagPath.each(
                (childPath, i) => {
                  const childNode = childPath.getValue();
                  const isText2 = isTextLike(childNode, node);
                  if (isText2) {
                    textDocs.push(print(childPath));
                    if (i !== lastIndex)
                      return;
                  } else {
                    textOnly = false;
                  }
                  if (textDocs.length) {
                    const isFirst = !bodyDocs.length;
                    bodyDocs.push(
                      b5.group([
                        opts.markoSyntax === "html" ? "" : isFirst ? b5.ifBreak("--", " --", { groupId }) : "--",
                        opts.markoSyntax === "html" ? "" : preserveSpace ? b5.hardline : b5.line,
                        preserveSpace ? textDocs : b5.fill(textDocs),
                        opts.markoSyntax === "html" ? "" : b5.ifBreak([b5.softline, "--"])
                      ])
                    );
                    if (!isText2) {
                      textDocs = [];
                      bodyDocs.push(print(childPath));
                    }
                  } else {
                    bodyDocs.push(print(childPath));
                  }
                },
                "body",
                "body"
              );
            }
            const joinSep = (preserveSpace || !textOnly) && (opts.markoSyntax === "concise" || node.body.body.some((child) => child.type === "MarkoScriptlet")) ? b5.hardline : preserveSpace ? "" : b5.softline;
            const wrapSep = !preserveSpace && opts.markoSyntax === "html" && (node.var || node.body.params.length || ((_c = node.arguments) == null ? void 0 : _c.length) || node.attributes.length || node.body.body.some((child) => !isTextLike(child, node))) ? b5.hardline : joinSep;
            if (opts.markoSyntax === "html") {
              doc6.push(">");
            }
            if (joinSep || wrapSep) {
              doc6.push(b5.indent([wrapSep, b5.join(joinSep, bodyDocs)]));
              if (opts.markoSyntax === "html") {
                doc6.push(wrapSep);
              }
            } else {
              doc6.push(...bodyDocs);
            }
            if (opts.markoSyntax === "html") {
              doc6.push(`</${literalTagName}>`);
            }
          } else if (opts.markoSyntax === "html") {
            doc6.push("/>");
          }
          opts.markoPreservingSpace = markoPreservingSpace;
          return withLineIfNeeded(node, opts, b5.group(doc6, { id: groupId }));
        }
        case "MarkoAttribute": {
          const attrPath = path;
          const doc6 = [];
          const { value } = node;
          if (!node.default) {
            doc6.push(node.name);
            if (node.modifier) {
              doc6.push(`:${node.modifier}`);
            }
            if ((_d = node.arguments) == null ? void 0 : _d.length) {
              doc6.push(
                b5.group([
                  "(",
                  b5.indent([
                    b5.softline,
                    b5.join(
                      [",", b5.line],
                      attrPath.map((it) => print(it), "arguments")
                    ),
                    opts.trailingComma === "all" ? b5.ifBreak(",") : ""
                  ]),
                  b5.softline,
                  ")"
                ])
              );
            }
          }
          if (node.default || !t.isBooleanLiteral(value, { value: true })) {
            if (t.isFunctionExpression(value) && !(value.id || value.async || value.generator)) {
              const methodBodyDocs = [];
              attrPath.each(
                (childPath) => {
                  var _a2;
                  if (((_a2 = childPath.getNode()) == null ? void 0 : _a2.type) !== "EmptyStatement") {
                    methodBodyDocs.push(print(childPath));
                  }
                },
                "value",
                "body",
                "body"
              );
              doc6.push(
                b5.group([
                  "(",
                  value.params.length ? callEmbed(
                    print,
                    attrPath,
                    "params",
                    getOriginalCodeForList(opts, ",", value.params)
                  ) : "",
                  ")"
                ]),
                methodBodyDocs.length ? b5.group([
                  " {",
                  b5.indent([b5.line, b5.join(b5.hardline, methodBodyDocs)]),
                  b5.line,
                  "}"
                ]) : " {}"
              );
            } else {
              doc6.push(
                node.bound ? ":=" : "=",
                b5.group(
                  withParensIfNeeded(value, opts, attrPath.call(print, "value"))
                )
              );
            }
          }
          return doc6;
        }
        case "MarkoSpreadAttribute": {
          return ["..."].concat(
            withParensIfNeeded(
              node.value,
              opts,
              path.call(print, "value")
            )
          );
        }
        case "MarkoPlaceholder":
          return [
            node.escape ? "${" : "$!{",
            path.call(print, "value"),
            "}"
          ];
        case "MarkoScriptlet": {
          const bodyDocs = [];
          const prefix = node.static ? "static" : "$";
          path.each((childPath) => {
            const childNode = childPath.getNode();
            if (childNode && childNode.type !== "EmptyStatement") {
              bodyDocs.push(
                withLineIfNeeded(
                  childNode,
                  opts,
                  printSpecialDeclaration(childPath, prefix, opts, print) || [
                    prefix + " ",
                    withBlockIfNeeded(childNode, opts, childPath.call(print))
                  ]
                )
              );
            }
          }, "body");
          return b5.join(b5.hardline, bodyDocs);
        }
        case "MarkoText": {
          const quote = opts.singleQuote ? "'" : '"';
          const escapedSpace = `\${${quote} ${quote}}`;
          const { value } = node;
          if (value === " " && (opts.markoSyntax === "concise" || path.getParentNode().type === "Program")) {
            return escapedSpace;
          }
          const breakValue = value.replace(/^ | $/g, escapedSpace);
          if (breakValue === value) {
            return asLiteralTextContent(value);
          }
          return b5.ifBreak(
            asLiteralTextContent(breakValue),
            asLiteralTextContent(value)
          );
        }
        default:
          throw new Error(`Unknown node type in Marko template: ${node.type}`);
      }
    },
    embed(path, print, toDoc, opts) {
      const node = path.getValue();
      switch (node.type) {
        case "_MarkoEmbed":
          switch (node.mode) {
            case "var": {
              return tryPrintEmbed(
                `var ${node.code}=_`,
                opts.markoScriptParser,
                (doc6) => {
                  const contents = doc6[0].contents[1].contents;
                  for (let i = contents.length; i--; ) {
                    const item = contents[i];
                    if (typeof item === "string") {
                      const match = /\s*=\s*$/.exec(item);
                      if (match) {
                        contents[i] = item.slice(0, -match[0].length);
                        contents.length = i + 1;
                        break;
                      }
                    }
                  }
                  return contents;
                },
                node.code
              );
            }
            case "params": {
              return tryPrintEmbed(
                toExpression(`(${node.code})=>_`),
                expressionParser,
                (doc6) => {
                  const { contents } = doc6.contents[0];
                  if (Array.isArray(contents) && contents[0].startsWith("(")) {
                    contents[0] = contents[0].slice(1);
                    contents[contents.length - 1] = contents[contents.length - 1].slice(0, -1);
                  }
                  return contents;
                },
                node.code
              );
            }
            case "script":
              return tryPrintEmbed(node.code, opts.markoScriptParser);
            default: {
              if (!node.mode.startsWith("style.")) {
                return [b5.trim, asLiteralTextContent(node.code)];
              }
              return tryPrintEmbed(node.code, node.mode.slice("style.".length));
            }
          }
        case "MarkoClass":
          return toDoc(
            toExpression(`class ${getOriginalCodeForNode(opts, node.body)}`),
            { parser: expressionParser },
            { stripTrailingHardline: true }
          );
        case "File":
        case "Program":
        case "EmptyStatement":
          return null;
        case "ExportNamedDeclaration":
          if (node.declaration) {
            const printedDeclaration = path.call(
              (childPath) => printSpecialDeclaration(childPath, "export", opts, print),
              "declaration"
            );
            if (printedDeclaration)
              return printedDeclaration;
          }
          break;
        default:
          if (node.type.startsWith("Marko")) {
            return null;
          }
      }
      if (t.isStatement(node)) {
        return tryPrintEmbed(
          getOriginalCodeForNode(opts, node),
          opts.markoScriptParser
        );
      } else {
        return tryPrintEmbed(
          toExpression(getOriginalCodeForNode(opts, node)),
          expressionParser
        );
      }
      function tryPrintEmbed(code, parser, normalize = identity, fallback = code) {
        try {
          return normalize(
            toDoc(code, { parser }, { stripTrailingHardline: true })
          );
        } catch {
          return [asLiteralTextContent(fallback)];
        }
      }
    }
  }
};
function printSpecialDeclaration(path, prefix, opts, print) {
  const node = path.getValue();
  switch (node.type) {
    case "TSTypeAliasDeclaration":
      return [
        prefix + " type ",
        node.id.name,
        node.typeParameters ? [
          "<",
          b5.group([
            b5.indent([
              b5.softline,
              path.call(
                (paramsPath) => b5.join(
                  [",", b5.line],
                  paramsPath.map((param) => param.call(print))
                ),
                "typeParameters",
                "params"
              )
            ]),
            b5.softline,
            ">"
          ])
        ] : "",
        " = ",
        withParensIfBreak(
          node.typeAnnotation,
          opts,
          path.call(print, "typeAnnotation")
        ),
        opts.semi ? ";" : ""
      ];
    case "VariableDeclaration": {
      return b5.join(
        b5.hardline,
        path.map((declPath) => {
          const decl = declPath.getValue();
          decl.id;
          return [
            prefix + " " + (node.declare ? "declare " : "") + node.kind + " ",
            callEmbed(
              print,
              declPath,
              "var",
              getOriginalCodeForNode(opts, decl.id)
            ),
            decl.init ? [
              " = ",
              withParensIfBreak(
                decl.init,
                opts,
                declPath.call(print, "init")
              )
            ] : "",
            opts.semi ? ";" : ""
          ];
        }, "declarations")
      );
    }
  }
}
function replaceEmbeddedPlaceholders(doc6, placeholders) {
  if (!placeholders.length)
    return doc6;
  return utils.mapDoc(doc6, (cur) => {
    if (typeof cur === "string") {
      let match = embeddedPlaceholderReg.exec(cur);
      if (match) {
        const replacementDocs = [];
        let index = 0;
        do {
          const placeholderIndex = +match[1];
          if (index !== match.index) {
            replacementDocs.push(cur.slice(index, match.index));
          }
          replacementDocs.push(placeholders[placeholderIndex]);
          index = match.index + match[0].length;
        } while (match = embeddedPlaceholderReg.exec(cur));
        if (index !== cur.length) {
          replacementDocs.push(cur.slice(index));
        }
        if (replacementDocs.length === 1) {
          return replacementDocs[0];
        }
        return replacementDocs;
      }
    }
    return cur;
  });
}
function toExpression(code) {
  return `(${code}
)`;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  languages,
  options,
  parsers,
  printers
});
