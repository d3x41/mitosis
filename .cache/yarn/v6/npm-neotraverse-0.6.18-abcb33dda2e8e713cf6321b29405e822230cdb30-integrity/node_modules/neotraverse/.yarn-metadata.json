{
  "manifest": {
    "name": "neotraverse",
    "version": "0.6.18",
    "description": "traverse and transform objects by visiting every node on a recursive walk",
    "main": "dist/legacy/legacy.cjs",
    "type": "module",
    "types": "dist/index.d.ts",
    "files": [
      "dist",
      "legacy.*"
    ],
    "exports": {
      ".": {
        "types": "./dist/index.d.ts",
        "import": {
          "production": "./dist/min/index.js",
          "development": "./dist/index.js",
          "default": "./dist/index.js"
        },
        "default": "./dist/min/index.js"
      },
      "./modern": {
        "types": "./dist/modern/modern.d.ts",
        "import": {
          "production": "./dist/modern/min/modern.js",
          "development": "./dist/modern/modern.js",
          "default": "./dist/modern/modern.js"
        },
        "default": "./dist/modern/modern.js"
      },
      "./legacy": {
        "require": {
          "types": "./dist/legacy/legacy.d.cts",
          "default": "./dist/legacy/legacy.cjs"
        },
        "import": {
          "types": "./dist/legacy/legacy.d.ts",
          "default": "./dist/legacy/legacy.mjs"
        },
        "default": "./dist/legacy/legacy.cjs"
      },
      "./package.json": "./package.json"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/PuruVJ/neotraverse.git"
    },
    "homepage": "https://github.com/PuruVJ/neotraverse",
    "keywords": [
      "traverse",
      "walk",
      "recursive",
      "map",
      "forEach",
      "deep",
      "clone"
    ],
    "author": {
      "name": "Puru Vijay, James Halliday"
    },
    "publishConfig": {
      "provenance": true
    },
    "license": "MIT",
    "engines": {
      "node": ">= 10"
    },
    "devDependencies": {
      "@changesets/cli": "^2.27.7",
      "@swc/core": "^1.6.13",
      "@types/node": "^20.14.10",
      "terser": "^5.31.2",
      "tsup": "^8.1.0",
      "typescript": "^5.5.3",
      "vitest": "^2.0.1"
    },
    "scripts": {
      "compile": "tsup && cp dist/legacy/legacy.cjs legacy.js && cp dist/legacy/legacy.d.cts legacy.d.ts",
      "test": "vitest run",
      "pub": "pnpm run compile && npm publish --access public --no-git-checks",
      "changeset": "changeset",
      "ci:version": "changeset version",
      "ci:release": "changeset publish"
    },
    "_registry": "npm",
    "_loc": "/home/user/.cache/yarn/v6/npm-neotraverse-0.6.18-abcb33dda2e8e713cf6321b29405e822230cdb30-integrity/node_modules/neotraverse/package.json",
    "readmeFilename": "README.md",
    "readme": "# neotraverse\n\nTraverse and transform objects by visiting every node on a recursive walk. This is a fork and TypeScript rewrite of [traverse](https://github.com/ljharb/js-traverse) with 0 dependencies and major improvements:\n\n- ðŸ¤Œ 1.38KB min+brotli\n- ðŸš¥ Zero dependencies\n- ðŸŽ¹ TypeScript. Throw away the `@types/traverse` package\n- âŽ No polyfills\n- ðŸ›¸ ESM-first\n- ðŸ“œ Legacy mode supporting ES5\n\n# Principles\n\nRules this package aims to follow for an indefinite period of time:\n\n- No dependencies.\n- No polyfills.\n- ESM-first.\n- Pushing to be modern\n- Always provide a legacy mode\n- Always follow `traverse` API. There already are many packages that do this. `neotraverse` intends to be a drop-in replacement for `traverse` and provide the same API with 0 dependencies and enhanced Developer Experience.\n- All deviating changes happen in `neotraverse/modern` build.\n\n# Modern build\n\n`neotraverse/modern` provides a new class `new Traverse()`, and all methods and state is provided as first argument `ctx` (`this.update -> ctx.update`, `this.isLeaf -> ctx.isLeaf`, etc.)\n\nBefore:\n\n```js\nimport traverse from 'neotraverse';\n\nconst obj = { a: 1, b: 2, c: [3, 4] };\n\ntraverse(obj).forEach(function (x) {\n  if (x < 0) this.update(x + 128);\n});\n```\n\nAfter:\n\n```js\nimport { Traverse } from 'neotraverse/modern';\n\nconst obj = { a: 1, b: 2, c: [3, 4] };\n\nnew Traverse(obj).forEach((ctx, x) => {\n  if (x < 0) ctx.update(x + 128);\n});\n```\n\n# Which build to use?\n\n`neotraverse` provides 3 builds:\n\n- default: Backwards compatible with `traverse` and provides the same API, but ESM only and compiled to ES2022 with Node 18+\n- modern: Modern build with ESM only and compiled to ES2022 with Node 18+. Provides a new class `new Traverse()`, and all methods and state is provided as first argument `ctx` (`this.update -> ctx.update`, `this.isLeaf -> ctx.isLeaf`, etc.)\n- legacy: Legacy build with ES5 and CJS, compatible with `traverse` and provides the same API.\n\nHere's a matrix of the different builds:\n\n| Build   | ESM       | CJS | Browser | Node | Polyfills | Size              |\n| ------- | --------- | --- | ------- | ---- | --------- | ----------------- |\n| default | âœ… ES2022 |     | âœ…      | âœ…   | âŒ        | 1.54KB min+brotli |\n| modern  | âœ… ES2022 |     | âœ…      | âœ…   | âŒ        | 1.38KB min+brotli |\n| legacy  | âœ… ES5    | âœ…  | âœ…      | âœ…   | âŒ        | 2.73KB min+brotli |\n\nIf you are:\n\n## starting from scratch\n\n```ts\nimport { Traverse } from 'neotraverse/modern';\n\nconst obj = { a: 1, b: 2, c: [3, 4] };\n\nnew Traverse(obj).forEach((ctx, x) => {\n  if (x < 0) ctx.update(x + 128); // `this` is same as `ctx` when using regular function\n});\n```\n\n## migrating from `traverse`\n\n### and you don't care about old browsers or Node versions:\n\nUse default build for no breaking changes, and a modern build for better developer experience.\n\n```ts\nimport traverse from 'neotraverse';\n\nconst obj = { a: 1, b: 2, c: [3, 4] };\n\ntraverse(obj).forEach(function (x) {\n  if (x < 0) this.update(x + 128);\n});\n```\n\n### and you care about old browsers or Node versions:\n\nUse legacy build for compatibility with old browsers and Node versions.\n\n```js\nconst traverse = require('neotraverse/legacy');\n```\n\nESM:\n\n```js\nimport traverse from 'neotraverse/legacy';\n```\n\n# examples\n\n## transform negative numbers in-place\n\nnegative.js\n\n```js\nimport { Traverse } from 'neotraverse/modern';\nconst obj = [5, 6, -3, [7, 8, -2, 1], { f: 10, g: -13 }];\n\nnew Traverse(obj).forEach(function (ctx, x) {\n  if (x < 0) ctx.update(x + 128);\n});\n\nconsole.dir(obj);\n```\n\nor in legacy mode:\n\n```js\nimport traverse from 'neotraverse';\n// OR import traverse from 'neotraverse/legacy';\n\nconst obj = [5, 6, -3, [7, 8, -2, 1], { f: 10, g: -13 }];\n\ntraverse(obj).forEach(function (x) {\n  if (x < 0) this.update(x + 128);\n});\n\n// This is identical to the above\ntraverse.forEach(obj, function (x) {\n  if (x < 0) this.update(x + 128);\n});\n\nconsole.dir(obj);\n```\n\nOutput:\n\n    [ 5, 6, 125, [ 7, 8, 126, 1 ], { f: 10, g: 115 } ]\n\n## collect leaf nodes\n\nleaves.js\n\n```js\nimport { Traverse } from 'neotraverse/modern';\n\nconst obj = {\n  a: [1, 2, 3],\n  b: 4,\n  c: [5, 6],\n  d: { e: [7, 8], f: 9 }\n};\n\nconst leaves = new Traverse(obj).reduce((ctx, acc, x) => {\n  if (ctx.isLeaf) acc.push(x);\n  return acc;\n}, []);\n\nconsole.dir(leaves);\n```\n\nor in legacy mode:\n\n```js\nimport traverse from 'neotraverse';\n// OR import traverse from 'neotraverse/legacy';\n\nconst obj = {\n  a: [1, 2, 3],\n  b: 4,\n  c: [5, 6],\n  d: { e: [7, 8], f: 9 }\n};\n\nconst leaves = traverse(obj).reduce(function (acc, x) {\n  if (this.isLeaf) acc.push(x);\n  return acc;\n}, []);\n\n// Equivalent to the above\nconst leavesLegacy = traverse.reduce(\n  obj,\n  function (acc, x) {\n    if (this.isLeaf) acc.push(x);\n    return acc;\n  },\n  []\n);\n\nconsole.dir(leaves);\nconsole.dir(leavesLegacy);\n```\n\nOutput:\n\n    [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n\n## scrub circular references\n\nscrub.js:\n\n```js\nimport { Traverse } from 'neotraverse/modern';\n\nconst obj = { a: 1, b: 2, c: [3, 4] };\nobj.c.push(obj);\n\nconst scrubbed = new Traverse(obj).map(function (ctx, x) {\n  if (ctx.circular) ctx.remove();\n});\n\nconsole.dir(scrubbed);\n```\n\nor in legacy mode:\n\n```js\nimport traverse from 'neotraverse';\n// OR import traverse from 'neotraverse/legacy';\n\nconst obj = { a: 1, b: 2, c: [3, 4] };\nobj.c.push(obj);\n\nconst scrubbed = traverse(obj).map(function (x) {\n  if (this.circular) this.remove();\n});\n\n// Equivalent to the above\nconst scrubbedLegacy = traverse.map(obj, function (x) {\n  if (this.circular) this.remove();\n});\n\nconsole.dir(scrubbed);\nconsole.dir(scrubbedLegacy);\n```\n\noutput:\n\n    { a: 1, b: 2, c: [ 3, 4 ] }\n\n## commonjs\n\nneotraverse/legacy is compatible with commonjs and provides the same API as `traverse`, acting as a drop-in replacement:\n\n```js\nconst traverse = require('neotraverse/legacy');\n```\n\n## esm\n\n```js\nimport { Traverse } from 'neotraverse/modern';\n```\n\n```js\nimport traverse from 'neotraverse';\n```\n\n# Differences from `traverse`\n\n- ESM-first\n- ES2022, Node 18+\n- Types included by default. No need to install `@types/traverse`\n- Works as-is in all major browsers and Deno\n- No polyfills\n- `new Traverse()` class instead of regular old `traverse()`\n- Legacy mode supporting `ES5` and `CJS`\n\nThere is a legacy mode that provides the same API as `traverse`, acting as a drop-in replacement:\n\n```js\nimport traverse from 'neotraverse';\n\nconst obj = { a: 1, b: 2, c: [3, 4] };\n\ntraverse(obj).forEach(function (x) {\n  if (x < 0) this.update(x + 128);\n});\n```\n\nIf you want to support really old browsers or NodeJS, supporting ES5, there's `neotraverse/legacy` which is compatible with ES5 and provides the same API as `traverse`, acting as a drop-in replacement for older browsers:\n\n```js\nimport traverse from 'neotraverse/legacy';\n\nconst obj = { a: 1, b: 2, c: [3, 4] };\n\ntraverse(obj).forEach(function (x) {\n  if (x < 0) this.update(x + 128);\n});\n```\n\n# Migrating from `traverse`\n\n### Step 1: Install `neotraverse`\n\n```sh\nnpm install neotraverse\nnpm uninstall traverse @types/traverse # Remove the old dependencies\n```\n\n### Step 2: Replace `traverse` with `neotraverse`\n\n```diff\n-import traverse from 'traverse';\n+import traverse from 'neotraverse';\n\nconst obj = { a: 1, b: 2, c: [3, 4] };\n\n-traverse(obj).forEach(function (x) {\n+traverse(obj).forEach(function (x) {\n  if (x < 0) this.update(x + 128);\n});\n```\n\nOptionally, there's also a legacy mode that provides the same API as `traverse`, acting as a drop-in replacement:\n\n```js\nimport traverse from 'neotraverse/legacy';\n\nconst obj = { a: 1, b: 2, c: [3, 4] };\n\ntraverse(obj).forEach(function (x) {\n  if (x < 0) this.update(x + 128);\n});\n```\n\n### Step 3(Optional): Bundle time aliasing\n\nIf you use Vite, you can aliss `traverse` to `neotravers/legacy` in your `vite.config.js`:\n\n```js\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n  resolve: {\n    alias: {\n      traverse: 'neotraverse' // or 'neotraverse/legacy'\n    }\n  }\n});\n```\n\n# methods\n\nEach method that takes an `fn` uses the context documented below in the context section.\n\n## .map(fn)\n\nExecute `fn` for each node in the object and return a new object with the results of the walk. To update nodes in the result use `ctx.update(value)`(modern) or `this.update(value)`(legacy).\n\n## .forEach(fn)\n\nExecute `fn` for each node in the object but unlike `.map()`, when `ctx.update()`(modern) or `this.update()`(legacy) is called it updates the object in-place.\n\n## .reduce(fn, acc)\n\nFor each node in the object, perform a [left-fold](<http://en.wikipedia.org/wiki/Fold_(higher-order_function)>) with the return value of `fn(acc, node)`.\n\nIf `acc` isn't specified, `acc` is set to the root object for the first step and the root element is skipped.\n\n## .paths()\n\nReturn an `Array` of every possible non-cyclic path in the object. Paths are `Array`s of string keys.\n\n## .nodes()\n\nReturn an `Array` of every node in the object.\n\n## .clone()\n\nCreate a deep clone of the object.\n\n## .get(path)\n\nGet the element at the array `path`.\n\n## .set(path, value)\n\nSet the element at the array `path` to `value`.\n\n## .has(path)\n\nReturn whether the element at the array `path` exists.\n\n# context\n\nEach method that takes a callback has a context (its `ctx` object, or `this` object in legacy mode) with these attributes:\n\n## this.node\n\nThe present node on the recursive walk\n\n## this.path\n\nAn array of string keys from the root to the present node\n\n## this.parent\n\nThe context of the node's parent. This is `undefined` for the root node.\n\n## this.key\n\nThe name of the key of the present node in its parent. This is `undefined` for the root node.\n\n## this.isRoot, this.notRoot\n\nWhether the present node is the root node\n\n## this.isLeaf, this.notLeaf\n\nWhether or not the present node is a leaf node (has no children)\n\n## this.level\n\nDepth of the node within the traversal\n\n## this.circular\n\nIf the node equals one of its parents, the `circular` attribute is set to the context of that parent and the traversal progresses no deeper.\n\n## this.update(value, stopHere=false)\n\nSet a new value for the present node.\n\nAll the elements in `value` will be recursively traversed unless `stopHere` is true.\n\n## this.remove(stopHere=false)\n\nRemove the current element from the output. If the node is in an Array it will be spliced off. Otherwise it will be deleted from its parent.\n\n## this.delete(stopHere=false)\n\nDelete the current element from its parent in the output. Calls `delete` even on Arrays.\n\n## this.before(fn)\n\nCall this function before any of the children are traversed.\n\nYou can assign into `ctx.keys`(modern) or `this.keys`(legacy) here to traverse in a custom order.\n\n## this.after(fn)\n\nCall this function after any of the children are traversed.\n\n## this.pre(fn)\n\nCall this function before each of the children are traversed.\n\n## this.post(fn)\n\nCall this function after each of the children are traversed.\n\n# license\n\nMIT\n",
    "licenseText": "MIT License\n\nCopyright (c) 2010 James Halliday and contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/neotraverse/-/neotraverse-0.6.18.tgz#abcb33dda2e8e713cf6321b29405e822230cdb30",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/neotraverse/-/neotraverse-0.6.18.tgz",
    "hash": "abcb33dda2e8e713cf6321b29405e822230cdb30",
    "integrity": "sha512-Z4SmBUweYa09+o6pG+eASabEpP6QkQ70yHj351pQoEXIs8uHbaU2DWVmzBANKgflPa47A50PtB2+NgRpQvr7vA==",
    "registry": "npm",
    "packageName": "neotraverse",
    "cacheIntegrity": "sha512-Z4SmBUweYa09+o6pG+eASabEpP6QkQ70yHj351pQoEXIs8uHbaU2DWVmzBANKgflPa47A50PtB2+NgRpQvr7vA== sha1-q8sz3aLo5xPPYyGylAXoIiMM2zA="
  },
  "registry": "npm",
  "hash": "abcb33dda2e8e713cf6321b29405e822230cdb30"
}