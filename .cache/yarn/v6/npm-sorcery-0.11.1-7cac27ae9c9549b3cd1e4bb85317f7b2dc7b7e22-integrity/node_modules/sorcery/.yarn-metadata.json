{
  "manifest": {
    "name": "sorcery",
    "description": "Resolve a chain of sourcemaps back to the original source",
    "version": "0.11.1",
    "author": {
      "name": "Rich Harris"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/Rich-Harris/sorcery"
    },
    "main": "dist/sorcery.cjs.js",
    "jsnext:main": "dist/sorcery.es6.js",
    "license": "MIT",
    "dependencies": {
      "buffer-crc32": "^1.0.0",
      "minimist": "^1.2.0",
      "sander": "^0.5.0",
      "@jridgewell/sourcemap-codec": "^1.4.14"
    },
    "devDependencies": {
      "@rollup/plugin-buble": "^1.0.3",
      "@rollup/plugin-commonjs": "^26.0.1",
      "@rollup/plugin-node-resolve": "^15.2.3",
      "buble": "^0.20.0",
      "codecov.io": "^0.1.6",
      "coffee-script": "^1.10.0",
      "eslint": "^2.8.0",
      "glob": "^7.0.3",
      "istanbul": "^0.4.3",
      "less": "^2.6.1",
      "mocha": "^2.4.5",
      "promise-map-series": "^0.2.2",
      "remap-istanbul": "^0.6.3",
      "rollup": "^4.18.0",
      "source-map": "^0.5.3",
      "source-map-support": "^0.4.0",
      "uglify-js": "^2.6.2"
    },
    "bin": {
      "sorcery": "bin/sorcery"
    },
    "scripts": {
      "build": "rm -rf dist && rollup -c rollup.config.mjs",
      "pretest": "npm run build",
      "prepare-tests": "node test/samples/prepare-tests.js",
      "test": "mocha --compilers js:buble/register",
      "prepublish": "npm test",
      "lint": "eslint src",
      "pretest-coverage": "npm run build",
      "test-coverage": "rm -rf coverage/* && istanbul cover --report json node_modules/.bin/_mocha -- -u exports -R spec test/test.js",
      "posttest-coverage": "remap-istanbul -i coverage/coverage-final.json -o coverage/coverage-remapped.json -b dist && remap-istanbul -i coverage/coverage-final.json -o coverage/coverage-remapped.lcov -t lcovonly -b dist && remap-istanbul -i coverage/coverage-final.json -o coverage/coverage-remapped -t html -b dist",
      "ci": "npm run test-coverage && codecov < coverage/coverage-remapped.lcov"
    },
    "files": [
      "src/",
      "dist/",
      "bin/",
      "README.md"
    ],
    "_registry": "npm",
    "_loc": "/home/user/.cache/yarn/v6/npm-sorcery-0.11.1-7cac27ae9c9549b3cd1e4bb85317f7b2dc7b7e22-integrity/node_modules/sorcery/package.json",
    "readmeFilename": "README.md",
    "readme": "# sorcery.js\n\nSourcemaps are great - if you have a JavaScript file, and you minify it, your minifier can generate a map that lets you debug as though you were looking at the original uncompressed code.\n\nBut if you have more than one transformation - say you want to transpile your JavaScript, concatenate several files into one, and minify the result - it gets a little trickier. Each intermediate step needs to be able to both *ingest* a sourcemap and *generate* one, all the time pointing back to the original source.\n\nMost compilers don't do that. ([UglifyJS](https://github.com/mishoo/UglifyJS2) is an honourable exception.) So when you fire up devtools, instead of looking at the original source you find yourself looking at the final intermediate step in the chain of transformations.\n\n**Sorcery aims to fix that.** Given a file at the end of a transformation chain (e.g., your minified JavaScript), it will follow the entire chain back to the original source, and generate a new sourcemap that describes the whole process. How? Magic.\n\nThis is a work-in-progress - suitable for playing around with, but don't rely on it to debug air traffic control software or medical equipment. Other than that, it can't do much harm.\n\n\n## Usage\n\n### As a node module\n\nInstall sorcery locally:\n\n```bash\nnpm install sorcery\n```\n\n```js\nvar sorcery = require( 'sorcery' );\n\nsorcery.load( 'some/generated/code.min.js' ).then( function ( chain ) {\n  // generate a flattened sourcemap\n  var map = chain.apply(); // { version: 3, file: 'code.min.js', ... }\n\n  // get a JSON representation of the sourcemap\n  map.toString(); // '{\"version\":3,\"file\":\"code.min.js\",...}'\n\n  // get a data URI representation\n  map.toUrl(); // 'data:application/json;charset=utf-8;base64,eyJ2ZXJ...'\n\n  // write to a new file - this will create `output.js` and\n  // `output.js.map`, and will preserve relative paths. It\n  // returns a Promise\n  chain.write( 'output.js' );\n\n  // write to a new file but use an absolute path for the\n  // sourceMappingURL\n  chain.write( 'output.js', { absolutePath: true });\n\n  // write to a new file, but append the flattened sourcemap as a data URI\n  chain.write( 'output.js', { inline: true });\n\n  // overwrite the existing file\n  chain.write();\n  chain.write({ inline: true });\n\n  // find the origin of line x, column y. Returns an object with\n  // `source`, `line`, `column` and (if applicable) `name` properties.\n  // Note - for consistency with other tools, line numbers are always\n  // one-based, column numbers are always zero-based. It's daft, I know.\n  var loc = chain.trace( x, y );\n});\n\n// You can also use sorcery synchronously:\nvar chain = sorcery.loadSync( 'some/generated/code.min.js' );\nvar map = chain.apply();\nvar loc = chain.trace( x, y );\nchain.writeSync();\n```\n\n#### Advanced options\n\nYou can pass an optional second argument to `sorcery.load()` and `sorcery.loadSync()`, with zero or more of the following properties:\n\n* `content` - a map of `filename: contents` pairs. `filename` will be resolved against the current working directory if needs be\n* `sourcemaps` - a map of `filename: sourcemap` pairs, where `filename` is the name of the file the sourcemap is related to. This will override any `sourceMappingURL` comments in the file itself.\n\nFor example:\n\n```js\nsorcery.load( 'some/generated/code.min.js', {\n  content: {\n    'some/minified/code.min.js': '...',\n    'some/transpiled/code.js': '...',\n    'some/original/code.js': '...'\n  },\n  sourcemaps: {\n    'some/minified/code.min.js': {...},\n    'some/transpiled/code.js': {...}\n  }\n}).then( chain => {\n  /* ... */\n});\n```\n\nAny files not found will be read from the filesystem as normal.\n\n### On the command line\n\nFirst, install sorcery globally:\n\n```bash\nnpm install -g sorcery\n```\n\n```\nUsage:\n  sorcery [options]\n\nOptions:\n  -h, --help               Show help message\n  -v, --version            Show version\n  -i, --input <file>       Input file\n  -o, --output <file>      Output file (if absent, will overwrite input)\n  -d, --datauri            Append map as a data URI, rather than separate file\n  -x, --excludeContent     Don't populate the sourcesContent array\n```\n\nExamples:\n\n```bash\n# overwrite sourcemap in place (will write map to\n# some/generated/code.min.js.map, and update\n# sourceMappingURL comment if necessary\nsorcery -i some/generated/code.min.js\n\n# append flattened sourcemap as an inline data URI\n# (will delete existing .map file, if applicable)\nsorcery -d -i some/generated/code.min.js\n\n# write to a new file (will create newfile.js and\n# newfile.js.map)\nsorcery -i some/generated/code.min.js -o newfile.js\n```\n\n\n## License\n\nMIT\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/sorcery/-/sorcery-0.11.1.tgz#7cac27ae9c9549b3cd1e4bb85317f7b2dc7b7e22",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/sorcery/-/sorcery-0.11.1.tgz",
    "hash": "7cac27ae9c9549b3cd1e4bb85317f7b2dc7b7e22",
    "integrity": "sha512-o7npfeJE6wi6J9l0/5LKshFzZ2rMatRiCDwYeDQaOzqdzRJwALhX7mk/A/ecg6wjMu7wdZbmXfD2S/vpOg0bdQ==",
    "registry": "npm",
    "packageName": "sorcery",
    "cacheIntegrity": "sha512-o7npfeJE6wi6J9l0/5LKshFzZ2rMatRiCDwYeDQaOzqdzRJwALhX7mk/A/ecg6wjMu7wdZbmXfD2S/vpOg0bdQ== sha1-fKwnrpyVSbPNHku4Uxf3stx7fiI="
  },
  "registry": "npm",
  "hash": "7cac27ae9c9549b3cd1e4bb85317f7b2dc7b7e22"
}