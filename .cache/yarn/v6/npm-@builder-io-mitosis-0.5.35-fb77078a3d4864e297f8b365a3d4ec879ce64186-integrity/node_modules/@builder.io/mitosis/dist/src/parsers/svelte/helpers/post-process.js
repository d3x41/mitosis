"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.postProcess = exports.preventNameCollissions = void 0;
const generator_1 = __importDefault(require("@babel/generator"));
const parser = __importStar(require("@babel/parser"));
const types = __importStar(require("@babel/types"));
const replace_identifiers_1 = require("../../../helpers/replace-identifiers");
const bindings_1 = require("./bindings");
const getArgs = (code) => {
    try {
        let parsed = parser.parse(code);
        let body = parsed.program.body[0];
        if (types.isFunctionDeclaration(body)) {
            return body.params.map((p) => (0, generator_1.default)(p).code);
        }
    }
    catch (e) { }
    return [];
};
function preventNameCollissions(json, item) {
    let output = item.code;
    const argumentsOutput = getArgs(output);
    output = (0, replace_identifiers_1.replaceNodes)({
        code: output,
        nodeMaps: argumentsOutput.map((arg) => ({
            from: types.identifier(arg),
            to: types.identifier(`${arg}_`),
        })),
    });
    return (argumentsOutput === null || argumentsOutput === void 0 ? void 0 : argumentsOutput.length)
        ? {
            ...item,
            code: output,
            arguments: getArgs(output),
        }
        : { ...item, code: output };
}
exports.preventNameCollissions = preventNameCollissions;
function prependProperties(json, code) {
    return (0, replace_identifiers_1.replaceNodes)({
        code,
        nodeMaps: Object.keys(json.props).map((property) => ({
            from: types.identifier(property),
            to: types.memberExpression(types.identifier('props'), types.identifier(property)),
        })),
    });
}
function prependState(json, input) {
    let output = input;
    for (const stateKey of Object.keys(json.state)) {
        output = (0, replace_identifiers_1.replaceIdentifiers)({
            code: output,
            from: stateKey,
            to: `state.${stateKey}`,
        });
    }
    return output;
}
function addPropertiesAndState(json, input) {
    let output = input;
    output = prependProperties(json, output);
    output = prependState(json, output);
    return output;
}
function addPropertiesAndStateToNode(json, node) {
    var _a;
    for (const key of Object.keys(node.bindings)) {
        if (Object.prototype.hasOwnProperty.call(node.bindings, key)) {
            const value = node.bindings[key];
            node.bindings[key].code = addPropertiesAndState(json, (_a = value === null || value === void 0 ? void 0 : value.code) !== null && _a !== void 0 ? _a : '').trim();
        }
    }
}
function postProcessState(json) {
    for (const key of Object.keys(json.state)) {
        const item = json.state[key];
        if ((item === null || item === void 0 ? void 0 : item.type) !== 'property') {
            const output = preventNameCollissions(json, item);
            output.code = addPropertiesAndState(json, output.code);
            json.state[key] = {
                ...item,
                ...output,
            };
        }
    }
}
function postProcessChildren(json, children) {
    var _a;
    for (const node of children) {
        addPropertiesAndStateToNode(json, node);
        (0, bindings_1.processBindings)(json, node);
        let children = [];
        if (((_a = node.children) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            children = node.children;
        }
        const metaValues = (Object.values(node.meta) || []);
        if (metaValues.length > 0) {
            const metaChildren = metaValues.filter((item) => {
                return (item === null || item === void 0 ? void 0 : item['@type']) === '@builder.io/mitosis/node';
            });
            children = [...children, ...metaChildren];
        }
        postProcessChildren(json, children);
    }
}
function addPropertiesAndStateToHook(json, hook) {
    return {
        code: addPropertiesAndState(json, hook.code),
        deps: addPropertiesAndState(json, hook.deps || ''),
    };
}
function postProcessHooks(json) {
    const hookKeys = Object.keys(json.hooks);
    for (const key of hookKeys) {
        let hook = json.hooks[key];
        if (!hook) {
            continue;
        }
        if (Array.isArray(hook)) {
            hook.forEach((item, index) => {
                hook.splice(index, 1, addPropertiesAndStateToHook(json, item));
            });
        }
        else {
            hook = addPropertiesAndStateToHook(json, hook);
        }
    }
}
function postProcessContext(json) {
    var _a;
    for (const key of Object.keys(json.context.set)) {
        if ((_a = json.context.set[key]) === null || _a === void 0 ? void 0 : _a.ref) {
            json.context.set[key].ref = addPropertiesAndState(json, json.context.set[key].ref);
        }
    }
}
function postProcess(json) {
    // Call preventNameCollissions here, before the rest (where it applies -- function arguments for now)
    // State (everything except type === 'property')
    postProcessState(json);
    // Children
    postProcessChildren(json, json.children);
    // Hooks
    postProcessHooks(json);
    // Context
    postProcessContext(json);
}
exports.postProcess = postProcess;
