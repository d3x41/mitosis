"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseInstance = void 0;
const astring_1 = require("astring");
const compiler_1 = require("svelte/compiler");
const context_1 = require("./context");
const expressions_1 = require("./expressions");
const functions_1 = require("./functions");
const hooks_1 = require("./hooks");
const imports_1 = require("./imports");
const properties_1 = require("./properties");
const reactive_1 = require("./reactive");
const references_1 = require("./references");
const statements_1 = require("./statements");
const handleImportDeclaration = (json, node) => {
    (0, imports_1.parseImports)(json, node);
};
const handleExportNamedDeclaration = (json, node) => {
    (0, properties_1.parseProperties)(json, node);
};
const handleMemberExpression = (json, node, parent) => {
    (0, expressions_1.parseMemberExpression)(json, node, parent);
};
const handleExpressionStatement = (json, node, parent) => {
    if (node.expression.type === 'CallExpression') {
        if (node.expression.callee.type === 'MemberExpression') {
            handleMemberExpression(json, node, parent);
            return;
        }
        const callee = node.expression.callee;
        switch (callee.name) {
            case 'setContext': {
                (0, context_1.parseSetContext)(json, node);
                break;
            }
            case 'onMount': {
                (0, hooks_1.parseOnMount)(json, node);
                break;
            }
            case 'onDestroy': {
                (0, hooks_1.parseOnDestroy)(json, node);
                break;
            }
            case 'onAfterUpdate': {
                (0, hooks_1.parseAfterUpdate)(json, node);
                break;
            }
        }
        // No default
    }
    else if ((parent === null || parent === void 0 ? void 0 : parent.type) === 'Program') {
        json.hooks.onMount.push({
            code: (0, astring_1.generate)(node),
        });
    }
};
const handleFunctionDeclaration = (json, node) => {
    (0, functions_1.parseFunctions)(json, node);
};
const handleVariableDeclaration = (json, node) => {
    var _a, _b, _c, _d;
    const init = (_a = node.declarations[0]) === null || _a === void 0 ? void 0 : _a.init;
    if ((init === null || init === void 0 ? void 0 : init.type) === 'CallExpression' && ((_b = init === null || init === void 0 ? void 0 : init.callee) === null || _b === void 0 ? void 0 : _b.name) === 'getContext') {
        (0, context_1.parseGetContext)(json, node);
    }
    else if ((init === null || init === void 0 ? void 0 : init.type) === 'CallExpression' &&
        ((_c = init === null || init === void 0 ? void 0 : init.callee) === null || _c === void 0 ? void 0 : _c.name) === 'hasContext') {
        (0, context_1.parseHasContext)(json, node);
    }
    else if ((init === null || init === void 0 ? void 0 : init.type) === 'CallExpression' &&
        ((_d = init === null || init === void 0 ? void 0 : init.callee) === null || _d === void 0 ? void 0 : _d.name) === 'createEventDispatcher') {
        // ignore
    }
    else {
        (0, references_1.parseReferences)(json, node);
    }
};
const handleLabeledStatement = (json, node) => {
    if (node.label.name === '$') {
        (0, reactive_1.parseReactive)(json, node);
    }
};
const handleStatement = (json, node, parent) => {
    if ((parent === null || parent === void 0 ? void 0 : parent.type) === 'Program') {
        (0, statements_1.parseStatementAtProgramLevel)(json, node);
    }
};
function parseInstance(ast, json) {
    (0, compiler_1.walk)(ast.instance, {
        enter(node, parent) {
            switch (node.type) {
                case 'ImportDeclaration':
                    handleImportDeclaration(json, node);
                    break;
                case 'ExportNamedDeclaration':
                    handleExportNamedDeclaration(json, node);
                    break;
                case 'ExpressionStatement':
                    handleExpressionStatement(json, node, parent);
                    break;
                case 'FunctionDeclaration':
                    handleFunctionDeclaration(json, node);
                    break;
                case 'VariableDeclaration':
                    parent.type === 'Program' && handleVariableDeclaration(json, node);
                    break;
                case 'LabeledStatement':
                    handleLabeledStatement(json, node);
                    break;
                case 'IfStatement':
                case 'SwitchStatement':
                case 'TryStatement':
                case 'DoWhileStatement':
                case 'ForStatement':
                case 'ForInStatement':
                case 'ForOfStatement':
                    handleStatement(json, node, parent);
                    break;
            }
        },
    });
}
exports.parseInstance = parseInstance;
