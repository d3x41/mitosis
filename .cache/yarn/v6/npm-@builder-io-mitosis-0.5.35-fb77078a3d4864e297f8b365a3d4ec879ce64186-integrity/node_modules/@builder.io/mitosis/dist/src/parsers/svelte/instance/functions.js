"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseFunctions = void 0;
const types_1 = require("@babel/types");
const astring_1 = require("astring");
const lodash_1 = require("lodash");
const compiler_1 = require("svelte/compiler");
const string_1 = require("../helpers/string");
function parseFunctions(json, node) {
    const id = node.id;
    let dispatchEventName;
    let code = (0, astring_1.generate)(node);
    (0, compiler_1.walk)(node, {
        enter(node) {
            switch (node.type) {
                case 'CallExpression': {
                    const node_ = node;
                    const callee = node_.callee;
                    if ((callee === null || callee === void 0 ? void 0 : callee.name) === 'dispatch') {
                        dispatchEventName = (0, astring_1.generate)(node_.arguments[0]);
                    }
                    break;
                }
                case 'UpdateExpression': {
                    if ((0, types_1.isUpdateExpression)(node)) {
                        const expression = node;
                        if ((0, types_1.isIdentifier)(expression.argument)) {
                            const argument = expression.argument.name;
                            if (expression.operator === '++') {
                                code = code.replace('++', ` = ${argument} + 1`);
                            }
                            else if (expression.operator === '--') {
                                code = code.replace('--', ` = ${argument} - 1`);
                            }
                        }
                    }
                    break;
                }
                case 'AssignmentExpression': {
                    if ((0, types_1.isAssignmentExpression)(node)) {
                        const expression = node;
                        if ((0, types_1.isIdentifier)(expression.left)) {
                            const argument = expression.left.name;
                            if (expression.operator === '+=') {
                                code = code.replace('+=', `= ${argument} +`);
                            }
                            else if (expression.operator === '-=') {
                                code = code.replace('-=', `= ${argument} -`);
                            }
                        }
                    }
                    break;
                }
            }
        },
    });
    if (dispatchEventName) {
        const regex = new RegExp(`dispatch\\(${dispatchEventName},?`);
        code = code.replace(regex, `props.on${(0, lodash_1.capitalize)((0, string_1.stripQuotes)(dispatchEventName))}(`);
    }
    json.state[id.name] = {
        code,
        type: 'function',
    };
}
exports.parseFunctions = parseFunctions;
