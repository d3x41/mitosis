"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSignalsCode = void 0;
const function_1 = require("fp-ts/lib/function");
const patterns_1 = require("../../../helpers/patterns");
const helpers_1 = require("./helpers");
const processSignalStateValue = ({ options, component, }) => {
    const mapValue = (0, helpers_1.updateStateCode)({ options, component });
    return ([key, stateVal]) => {
        if (!stateVal) {
            return '';
        }
        const getDefaultCase = () => (0, function_1.pipe)(value, mapValue, (x) => `const [${key}, ${(0, helpers_1.getStateSetterName)(key)}] = createSignal(${x})`);
        const value = stateVal.code;
        const type = stateVal.type;
        if (typeof value === 'string') {
            switch (type) {
                case 'getter':
                    return (0, function_1.pipe)(value, mapValue, patterns_1.extractGetterCodeBlock, (x) => `const ${key} = createMemo(() => {${x}})`);
                case 'function':
                    return mapValue(value);
                case 'method':
                    return (0, function_1.pipe)(value, patterns_1.prefixWithFunction, mapValue);
                default:
                    return getDefaultCase();
            }
        }
        else {
            return getDefaultCase();
        }
    };
};
const LINE_ITEM_DELIMITER = '\n\n\n';
const getSignalsCode = ({ json, options, state, }) => Object.entries(state)
    .map(processSignalStateValue({ options, component: json }))
    /**
     * We need to sort state so that signals are at the top.
     */
    .sort((a, b) => {
    const aHasSignal = a.includes('createSignal(');
    const bHasSignal = b.includes('createSignal(');
    if (aHasSignal && !bHasSignal) {
        return -1;
    }
    else if (!aHasSignal && bHasSignal) {
        return 1;
    }
    else {
        return 0;
    }
})
    .join(LINE_ITEM_DELIMITER);
exports.getSignalsCode = getSignalsCode;
