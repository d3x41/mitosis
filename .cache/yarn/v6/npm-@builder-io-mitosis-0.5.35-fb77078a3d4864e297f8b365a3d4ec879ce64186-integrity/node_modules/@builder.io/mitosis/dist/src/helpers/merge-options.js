"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initializeOptions = exports.mergeOptions = void 0;
const process_signals_1 = require("./plugins/process-signals");
const process_target_blocks_1 = require("./plugins/process-target-blocks");
/**
 * Merges options while combining the `plugins` array, and adds any default plugins.
 */
const mergeOptions = (a, b = {}, c, d) => {
    return {
        ...a,
        ...b,
        ...c,
        ...d,
        plugins: [
            ...(a.plugins || []),
            ...(b.plugins || []),
            ...((c === null || c === void 0 ? void 0 : c.plugins) || []),
            ...((d === null || d === void 0 ? void 0 : d.plugins) || []),
        ],
    };
};
exports.mergeOptions = mergeOptions;
/**
 * Merges options while combining the `plugins` array, and adds any default plugins.
 */
const initializeOptions = ({ target, component, defaults, userOptions, extra, }) => {
    var _a, _b, _c;
    const metadataOverrides = (_c = (_b = (_a = component.meta) === null || _a === void 0 ? void 0 : _a.useMetadata) === null || _b === void 0 ? void 0 : _b.options) === null || _c === void 0 ? void 0 : _c[target];
    const options = (0, exports.mergeOptions)(defaults, userOptions, extra, metadataOverrides);
    // we want this plugin to run first in every case, as it replaces magic strings with the correct code.
    options.plugins.unshift((0, process_target_blocks_1.processTargetBlocks)(target), (0, process_signals_1.getSignalTypePlugin)({ target }), (0, process_signals_1.getSignalAccessPlugin)({ target }));
    return options;
};
exports.initializeOptions = initializeOptions;
