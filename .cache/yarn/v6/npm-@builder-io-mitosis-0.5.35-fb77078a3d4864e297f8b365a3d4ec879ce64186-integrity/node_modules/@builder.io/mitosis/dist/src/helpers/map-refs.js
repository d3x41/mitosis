"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapRefs = void 0;
const core_1 = require("@babel/core");
const legacy_1 = __importDefault(require("neotraverse/legacy"));
const babel_transform_1 = require("./babel-transform");
const get_refs_1 = require("./get-refs");
const is_mitosis_node_1 = require("./is-mitosis-node");
const patterns_1 = require("./patterns");
const replaceRefsInString = (code, refs, mapper) => {
    return (0, babel_transform_1.babelTransformExpression)(code, {
        Identifier(path) {
            const name = path.node.name;
            const isRef = refs.includes(name);
            if (isRef) {
                path.replaceWith(core_1.types.identifier(mapper(name)));
            }
        },
    });
};
const mapRefs = (component, mapper) => {
    const refSet = (0, get_refs_1.getRefs)(component);
    // grab refs not used for bindings
    Object.keys(component.refs).forEach((ref) => refSet.add(ref));
    const refs = Array.from(refSet);
    for (const key of Object.keys(component.state)) {
        const stateVal = component.state[key];
        if (typeof (stateVal === null || stateVal === void 0 ? void 0 : stateVal.code) === 'string') {
            const value = stateVal.code;
            switch (stateVal.type) {
                case 'method':
                case 'getter':
                    const isGet = stateVal.type === 'getter';
                    const isSet = Boolean(value.match(patterns_1.SETTER));
                    component.state[key] = {
                        ...stateVal,
                        code: replaceRefsInString(value.replace(/^(get |set )?/, 'function '), refs, mapper).replace(/^function /, isGet ? 'get ' : isSet ? 'set ' : ''),
                    };
                    break;
                case 'function':
                    component.state[key] = {
                        ...stateVal,
                        code: replaceRefsInString(value, refs, mapper),
                        type: 'function',
                    };
                    break;
                default:
                    break;
            }
        }
    }
    (0, legacy_1.default)(component).forEach(function (item) {
        if ((0, is_mitosis_node_1.isMitosisNode)(item)) {
            for (const key of Object.keys(item.bindings)) {
                const value = item.bindings[key];
                if (typeof value === 'object' && key !== 'ref') {
                    item.bindings[key] = {
                        ...value,
                        code: replaceRefsInString(value.code, refs, mapper),
                    };
                }
            }
        }
    });
    for (const key of Object.keys(component.hooks)) {
        const hooks = component.hooks[key];
        if (Array.isArray(hooks)) {
            hooks.forEach((hook) => {
                if (hook.code) {
                    hook.code = replaceRefsInString(hook.code, refs, mapper);
                }
                if (hook.deps) {
                    hook.deps = replaceRefsInString(hook.deps, refs, mapper);
                }
            });
        }
        else {
            const hookCode = hooks === null || hooks === void 0 ? void 0 : hooks.code;
            if (hookCode) {
                hooks.code = replaceRefsInString(hookCode, refs, mapper);
            }
            if (hooks === null || hooks === void 0 ? void 0 : hooks.deps) {
                hooks.deps = replaceRefsInString(hooks === null || hooks === void 0 ? void 0 : hooks.deps, refs, mapper);
            }
        }
    }
};
exports.mapRefs = mapRefs;
