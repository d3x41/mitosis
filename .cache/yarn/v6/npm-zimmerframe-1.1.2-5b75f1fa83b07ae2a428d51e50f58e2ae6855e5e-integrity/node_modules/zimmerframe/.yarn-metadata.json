{
  "manifest": {
    "name": "zimmerframe",
    "description": "A tool for walking ASTs",
    "version": "1.1.2",
    "repository": {
      "type": "git",
      "url": "https://github.com/Rich-Harris/zimmerframe"
    },
    "type": "module",
    "exports": {
      ".": {
        "types": "./types/index.d.ts",
        "import": "./src/walk.js"
      }
    },
    "types": "./types/index.d.ts",
    "files": [
      "src",
      "types"
    ],
    "devDependencies": {
      "dts-buddy": "^0.1.13",
      "typescript": "^5.1.6",
      "vitest": "^0.34.2"
    },
    "scripts": {
      "prepublishOnly": "dts-buddy -m zimmerframe:src/index.d.ts",
      "check": "tsc",
      "test": "vitest --run",
      "test:watch": "vitest"
    },
    "license": "MIT",
    "packageManager": "pnpm@8.6.12",
    "_registry": "npm",
    "_loc": "/home/user/.cache/yarn/v6/npm-zimmerframe-1.1.2-5b75f1fa83b07ae2a428d51e50f58e2ae6855e5e-integrity/node_modules/zimmerframe/package.json",
    "readmeFilename": "README.md",
    "readme": "# zimmerframe\n\nA tool for walking.\n\nSpecifically, it's a tool for walking an abstract syntax tree (AST), where every node is an object with a `type: string`. This includes [ESTree](https://github.com/estree/estree) nodes, such as you might generate with [Acorn](https://github.com/acornjs/acorn) or [Meriyah](https://github.com/meriyah/meriyah), but also includes things like [CSSTree](https://github.com/csstree/csstree) or an arbitrary AST of your own devising.\n\n## Usage\n\n```ts\nimport { walk } from 'zimmerframe';\nimport { parse } from 'acorn';\nimport { Node } from 'estree';\n\nconst program = parse(`\nlet message = 'hello';\nconsole.log(message);\n\nif (true) {\n  let answer = 42;\n  console.log(answer);\n}\n`);\n\n// You can pass in arbitrary state\nconst state = {\n  declarations: [],\n  depth: 0\n};\n\nconst transformed = walk(program as Node, state, {\n  _(node, { state, next }) {\n    // the `_` visitor is 'universal' — if provided,\n    // it will run for every node, before deferring\n    // to specialised visitors. you can pass a new\n    // `state` object to `next`\n    next({ ...state, answer: 42 });\n  },\n  VariableDeclarator(node, { state }) {\n    // `state` is passed into each visitor\n    if (node.id.type === 'Identifier') {\n      state.declarations.push({\n        depth: state.depth,\n        name: node.id.name\n      });\n    }\n  },\n  BlockStatement(node, { state, next, stop }) {\n    // you must call `next()` or `next(childState)`\n    // to visit child nodes\n    console.log('entering BlockStatement');\n    next({ ...state, depth: state.depth + 1 });\n    console.log('leaving BlockStatement');\n  },\n  Literal(node) {\n    // if you return something, it will replace\n    // the current node\n    if (node.value === 'hello') {\n      return {\n        ...node,\n        value: 'goodbye'\n      };\n    }\n  },\n  IfStatement(node, { visit }) {\n    // normally, returning a value will halt\n    // traversal into child nodes. you can\n    // transform children with the current\n    // visitors using `visit(node, state?)`\n    if (node.test.type === 'Literal' && node.test.value === true) {\n      return visit(node.consequent);\n    }\n  }\n});\n```\n\nThe `transformed` AST would look like this:\n\n```js\nlet message = 'goodbye';\nconsole.log(message);\n\n{\n  let answer = 42;\n  console.log(answer);\n}\n```\n\n## Types\n\nThe type of `node` in each visitor is inferred from the visitor's name. For example:\n\n```ts\nwalk(ast as estree.Node, state, {\n  ArrowFunctionExpression(node) {\n    // `node` is of type estree.ArrowFunctionExpression\n  }\n});\n```\n\nFor this to work, the first argument should be casted to an union of all the types you plan to visit.\n\nYou can import types from 'zimmerframe':\n\n```ts\nimport {\n  walk,\n  type Visitor,\n  type Visitors,\n  type Context\n} from 'zimmerframe';\nimport type { Node } from 'estree';\n\ninterface State {...}\n\nconst node: Node = {...};\nconst state: State = {...};\nconst visitors: Visitors<Node, State> =  {...}\n\nwalk(node, state, visitors);\n```\n\n## Context\n\nEach visitor receives a second argument, `context`, which is an object with the following properties and methods:\n\n- `next(state?: State): void` — a function that allows you to control when child nodes are visited, and which state they are visited with. If child visitors transform their inputs, this will return the transformed node (if not, returns `undefined`)\n- `path: Node[]` — an array of parent nodes. For example, to get the root node you would do `path.at(0)`; to get the current node's immediate parent you would do `path.at(-1)`\n- `state: State` — an object of the same type as the second argument to `walk`. Visitors can pass new state objects to their children with `next(childState)` or `visit(node, childState)`\n- `stop(): void` — prevents any subsequent traversal\n- `visit(node: Node, state?: State): Node` — returns the result of visiting `node` with the current set of visitors. If no `state` is provided, children will inherit the current state\n\n## Immutability\n\nASTs are regarded as immutable. If you return a transformed node from a visitor, then all parents of the node will be replaced with clones, but unchanged subtrees will reuse the existing nodes.\n\nFor example in this case, no transformation takes place, meaning that the returned value is identical to the original AST:\n\n```js\nconst transformed = walk(original, state, {\n  Literal(node) {\n    console.log(node.value);\n  }\n});\n\ntransformed === original; // true\n```\n\nIn this case, however, we replace one of the nodes:\n\n```js\nconst original = {\n  type: 'BinaryExpression',\n  operator: '+',\n  left: {\n    type: 'Identifier',\n    name: 'foo'\n  },\n  left: {\n    type: 'Identifier',\n    name: 'bar'\n  }\n};\n\nconst transformed = walk(original, state, {\n  Identifier(node) {\n    if (node.name === 'bar') {\n      return { ...node, name: 'baz' };\n    }\n  }\n});\n\ntransformed === original; // false, the BinaryExpression node is cloned\ntransformed.left === original.left; // true, we can safely reuse this node\n```\n\nThis makes it very easy to transform parts of your AST without incurring the performance and memory overhead of cloning the entire thing, and without the footgun of mutating it in place.\n\n## License\n\nMIT\n",
    "licenseText": "MIT License\n\nCopyright (c) 2023 [these people](https://github.com/Rich-Harris/zimmerframe/graphs/contributors)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/zimmerframe/-/zimmerframe-1.1.2.tgz#5b75f1fa83b07ae2a428d51e50f58e2ae6855e5e",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/zimmerframe/-/zimmerframe-1.1.2.tgz",
    "hash": "5b75f1fa83b07ae2a428d51e50f58e2ae6855e5e",
    "integrity": "sha512-rAbqEGa8ovJy4pyBxZM70hg4pE6gDgaQ0Sl9M3enG3I0d6H4XSAM3GeNGLKnsBpuijUow064sf7ww1nutC5/3w==",
    "registry": "npm",
    "packageName": "zimmerframe",
    "cacheIntegrity": "sha512-rAbqEGa8ovJy4pyBxZM70hg4pE6gDgaQ0Sl9M3enG3I0d6H4XSAM3GeNGLKnsBpuijUow064sf7ww1nutC5/3w== sha1-W3Xx+oOweuKkKNUeUPWOKuaFXl4="
  },
  "registry": "npm",
  "hash": "5b75f1fa83b07ae2a428d51e50f58e2ae6855e5e"
}