"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasFirstChildKeyAttribute = exports.transformState = exports.getDefaultProps = exports.getAppropriateTemplateFunctionKeys = exports.HELPER_FUNCTIONS = void 0;
const strip_state_and_props_refs_1 = require("../../../helpers/strip-state-and-props-refs");
const HELPER_FUNCTIONS = (isTs) => ({
    useObjectWrapper: `useObjectWrapper(...args${isTs ? ': any[]' : ''}) {
    let obj = {}
    args.forEach((arg) => {
      obj = { ...obj, ...arg };
    });
    return obj;
  }`,
    useObjectDotValues: `useObjectDotValues(obj${isTs ? ': any' : ''})${isTs ? ': any[]' : ''}) {
    return Object.values(obj);
  }`,
    useTypeOf: `useTypeOf(obj${isTs ? ': any' : ''})${isTs ? ': string' : ''}) {
    return typeof obj;
  }`,
    useJsonStringify: `useJsonStringify(...args${isTs ? ': any' : ''})${isTs ? ': string' : ''}) {
    return JSON.stringify(...args);
  }`,
    setAttributes: `setAttributes(el${isTs ? ': HTMLElement' : ''}, value${isTs ? ': any' : ''}, changes${isTs ? '?: any' : ''}) {
    if (!el) {
      return;
    }
    const target = typeof changes === 'undefined' ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith('on')) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)${isTs ? '!' : ''}();
        }
        this._listenerFns.set(key, this.renderer.listen(
          el,
          key.replace('on', '').toLowerCase(),
          target[key]
        ));
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? '');
      }
    });
  }`,
});
exports.HELPER_FUNCTIONS = HELPER_FUNCTIONS;
const getAppropriateTemplateFunctionKeys = (code) => Object.keys((0, exports.HELPER_FUNCTIONS)()).filter((key) => code.includes(key));
exports.getAppropriateTemplateFunctionKeys = getAppropriateTemplateFunctionKeys;
const getDefaultProps = ({ defaultProps }) => {
    if (!defaultProps)
        return '';
    const defalutPropsString = Object.keys(defaultProps)
        .map((prop) => {
        var _a;
        const value = defaultProps.hasOwnProperty(prop) ? (_a = defaultProps[prop]) === null || _a === void 0 ? void 0 : _a.code : 'undefined';
        return `${prop}: ${value}`;
    })
        .join(',');
    return `const defaultProps = {${defalutPropsString}};\n`;
};
exports.getDefaultProps = getDefaultProps;
/**
 * if any state "property" is trying to access state.* or props.*
 * then we need to move them to onInit where they can be accessed
 * @param json The MitosisComponent.
 */
const transformState = (json) => {
    Object.entries(json.state)
        .reverse()
        .forEach(([key, value]) => {
        var _a;
        if ((value === null || value === void 0 ? void 0 : value.type) === 'property') {
            if (value.code && (value.code.includes('state.') || value.code.includes('props.'))) {
                const code = (0, strip_state_and_props_refs_1.stripStateAndPropsRefs)(value.code, { replaceWith: 'this' });
                json.state[key].code = 'null';
                if (!((_a = json.hooks.onInit) === null || _a === void 0 ? void 0 : _a.code)) {
                    json.hooks.onInit = { code: '' };
                }
                json.hooks.onInit.code = `\nthis.${key} = ${code};\n${json.hooks.onInit.code}`;
            }
        }
    });
};
exports.transformState = transformState;
/**
 * Checks if the first child has a "key" attribute - used for "For" elements
 * @param node The node which should be "For"
 */
const hasFirstChildKeyAttribute = (node) => {
    var _a;
    if (!node.children || node.children.length === 0) {
        return false;
    }
    const firstChildBinding = node.children[0].bindings;
    return Boolean(firstChildBinding && ((_a = firstChildBinding.key) === null || _a === void 0 ? void 0 : _a.code));
};
exports.hasFirstChildKeyAttribute = hasFirstChildKeyAttribute;
